// app/api/kols/detect-mentions/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/db/client";
import {
  kolTweets,
  tweetTokenMentions,
  mentionSource,
} from "@/lib/db/schema";
import {
  eq,
  and,
  gte,
  lt,
  sql,
  inArray,
  desc,
} from "drizzle-orm";
import { extractMentions, type Mention } from "@/lib/tokens/extract";
import { buildTriggerKeyWithText } from "@/lib/tokens/triggerKey";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

/* ===================== Config & helpers ===================== */

const GT_BASE =
  process.env.GECKOTERMINAL_BASE ?? "https://api.geckoterminal.com/api/v2";

// Networks order when no hard constraint (Solana preferred for tickers/phrases)
const NETWORKS_PREFERRED = [
  "solana",
  "base",
  "eth",
  "bsc",
  "polygon",
  "arbitrum",
  "optimism",
  "avalanche",
  "fantom",
] as const;

// DEX priority: PumpSwap > Raydium > Meteora > others
const dexPriority = (name?: string) => {
  const s = String(name || "").toLowerCase();
  if (s.includes("pump")) return 3;     // PumpSwap / pump.fun pool routers etc.
  if (s.includes("raydium")) return 2;  // Raydium
  if (s.includes("meteora")) return 1;  // Meteora
  return 0;                              // others
};

// Chain/address helpers
const isEvmAddr = (s: string) => /^0x[a-fA-F0-9]{40}$/.test(s);
const isSolAddr = (s: string) => /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(s);
/** Lowercase only for EVM; keep Solana base58 as-is */
const canonAddr = (s: string) => (isEvmAddr(s) ? s.toLowerCase() : s);

// Prefer readable input for trigger text
function triggerInputFor(m: Mention) {
  if (m.source === "ca") return m.tokenKey || "";
  if (m.tokenDisplay?.startsWith("$")) return m.tokenDisplay;
  return `$${String(m.tokenKey || "").toUpperCase()}`;
}

/* ===================== Ranking utilities ===================== */

type VolUSD = { m5?: number; h1?: number; h6?: number; h24?: number };
type PoolAttrs = {
  reserve_in_usd?: number;
  volume_usd?: VolUSD;
  name?: string; // sometimes pool name contains dex name
};
type TokenAttrs = {
  market_cap_usd?: number | null;
  fdv_usd?: number | null;
};

type Candidate = {
  network: string;
  addr: string;
  symbol: string;
  dexName: string;
  dexScore: number;
  volume24h: number;
  reserveUsd: number;
  marketCap: number;
};

type GTToken = {
  id: string;
  symbol: string;
  address: string;
  attrs: TokenAttrs;
};
type GTDex = {
  id: string;
  name: string;
};

// metric pickers
function pickVolume(v?: VolUSD): number {
  if (!v) return 0;
  return (
    (typeof v.h24 === "number" && v.h24) ||
    (typeof v.h6 === "number" && v.h6) ||
    (typeof v.h1 === "number" && v.h1) ||
    (typeof v.m5 === "number" && v.m5) ||
    0
  );
}
function pickMcap(t?: TokenAttrs): number {
  if (!t) return 0;
  if (typeof t.market_cap_usd === "number") return t.market_cap_usd;
  if (typeof t.fdv_usd === "number") return t.fdv_usd;
  return 0;
}

/** Sort by: DEX priority (PumpSwap > Raydium > Meteora > others) > 24h volume > liquidity > market cap */
function compareCandidates(a: Candidate, b: Candidate): number {
  if (b.dexScore !== a.dexScore) return b.dexScore - a.dexScore;
  if (b.volume24h !== a.volume24h) return b.volume24h - a.volume24h;
  if (b.reserveUsd !== a.reserveUsd) return b.reserveUsd - a.reserveUsd;
  if (b.marketCap !== a.marketCap) return b.marketCap - a.marketCap;
  return 0;
}

/* ===================== GeckoTerminal resolver ===================== */

/**
 * Resolve `$ticker` to contract/mint by querying multiple networks in parallel.
 * - If forceNetwork is provided, query that family only.
 * - Otherwise prefer Solana and choose best pool by:
 *   DEX priority > 24h volume > liquidity(reserve) > market cap
 */
async function resolveTickersToContracts(
  tickers: string[],
  opts?: { forceNetwork?: "solana" | "evm"; preferSolana?: boolean }
) {
  const out = new Map<
    string,
    { tokenKey: string; tokenDisplay: string; boostedConf: number }
  >();

  const networks = (() => {
    if (opts?.forceNetwork === "solana") return ["solana"] as const;
    if (opts?.forceNetwork === "evm") {
      return ["base","eth","bsc","polygon","arbitrum","optimism","avalanche","fantom"] as const;
    }
    return NETWORKS_PREFERRED;
  })();

  for (const raw of tickers) {
    const ticker = raw.replace(/^\$+/, "").toLowerCase();
    const symbol = `$${ticker.toUpperCase()}`;

    const perNet = await Promise.all(
      networks.map(async (net) => {
        try {
          const url = `${GT_BASE}/search/pools?query=${encodeURIComponent(
            ticker,
          )}&network=${encodeURIComponent(net)}&include=base_token,quote_token,dex`;
          const res = await fetch(url, {
            headers: { accept: "application/json" },
            cache: "no-store",
          });
          if (!res.ok) return [] as Candidate[];

          const j: any = await res.json();
          const data = (Array.isArray(j?.data) ? j.data : []) as any[];
          const included = (Array.isArray(j?.included) ? j.included : []) as any[];

          // tokens map
          const tokens: GTToken[] = included
            .filter((x: any) => String(x?.type || "").includes("token"))
            .map((x: any): GTToken => ({
              id: String(x?.id ?? ""),
              symbol: String(x?.attributes?.symbol ?? ""),
              address: String(x?.attributes?.address ?? ""),
              attrs: {
                market_cap_usd: (x?.attributes?.market_cap_usd ?? x?.attributes?.fdv_usd ?? null) as number | null,
                fdv_usd: (x?.attributes?.fdv_usd ?? null) as number | null,
              },
            }));

          // dex map (id -> name)
          const dexes: GTDex[] = included
            .filter((x: any) => String(x?.type || "").includes("dex"))
            .map((x: any): GTDex => ({
              id: String(x?.id ?? ""),
              name: String(x?.attributes?.name ?? x?.attributes?.slug ?? ""),
            }));
          const dexNameById = new Map(dexes.map((d) => [d.id, d.name]));

          const cands: Candidate[] = [];
          for (const p of data) {
            const attrs = (p?.attributes ?? {}) as PoolAttrs;
            const rels = p?.relationships ?? {};

            const baseId: string = String(rels?.base_token?.data?.id ?? "");
            const quoteId: string = String(rels?.quote_token?.data?.id ?? "");
            const dexRelId: string = String(rels?.dex?.data?.id ?? "");

            const base = tokens.find((t: GTToken) => t.id === baseId);
            const quote = tokens.find((t: GTToken) => t.id === quoteId);

            const dexName =
              dexNameById.get(dexRelId) ||
              String((attrs as any).dex_name ?? attrs.name ?? "");

            const volume24h = pickVolume(attrs.volume_usd as VolUSD | undefined);
            const reserveUsd = Number(attrs.reserve_in_usd ?? 0);

            // prefer exact symbol match on either side
            const side = [base, quote].find(
              (t: GTToken | undefined) => String(t?.symbol || "").toLowerCase() === ticker,
            );

            if (side?.address && (isEvmAddr(side.address) || isSolAddr(side.address))) {
              cands.push({
                network: net,
                addr: canonAddr(side.address),
                symbol,
                dexName,
                dexScore: dexPriority(dexName),  // PumpSwap > Raydium > Meteora > others
                volume24h,
                reserveUsd,
                marketCap: pickMcap(side.attrs),
              });
            }
          }
          return cands;
        } catch {
          return [] as Candidate[];
        }
      }),
    );

    const all = perNet.flat();
    // If preferSolana, prefer best Solana candidate; else use global best
    const solBest = all.filter((c) => c.network === "solana").sort(compareCandidates)[0];
    const best = solBest || all.sort(compareCandidates)[0];

    if (best) {
      out.set(ticker, {
        tokenKey: best.addr,
        tokenDisplay: symbol,
        // small confidence boost when it's Solana AND top DEX
        boostedConf: (best.network === "solana" ? 98 : 96) + (best.dexScore > 0 ? 1 : 0),
      });
    } else {
      // fallback: keep ticker itself
      out.set(ticker, {
        tokenKey: ticker,
        tokenDisplay: symbol,
        boostedConf: 95,
      });
    }
  }

  return out;
}

/* ===================== Request body ===================== */

const Body = z.object({
  screen_name: z.string().min(1),
  days: z.number().int().min(1).max(30).optional().default(7),
  /** Only run detection for tweets that have no mentions yet */
  missingOnly: z.boolean().optional().default(true),
});

/* ===================== Route ===================== */

export async function POST(req: Request) {
  // Admin auth
  const session = await getServerSession(authOptions);
  const isAdmin = Boolean((session?.user as any)?.isAdmin);
  if (!isAdmin) {
    return NextResponse.json({ ok: false, error: "forbidden" }, { status: 403 });
  }

  const { screen_name, days, missingOnly } = Body.parse(await req.json());
  const handle = screen_name.trim().replace(/^@+/, "").toLowerCase();

  // Time window [since, until)
  const now = new Date();
  const since = new Date(now);
  since.setDate(now.getDate() - (days - 1));
  const until = new Date(now);
  until.setDate(now.getDate() + 1);

  // Load tweets
  const tweets = await db
    .select({
      tweetId: kolTweets.tweetId,
      textContent: kolTweets.textContent,
      published: kolTweets.publishDate,
    })
    .from(kolTweets)
    .where(
      and(
        eq(kolTweets.twitterUsername, handle),
        gte(kolTweets.publishDate, since),
        lt(kolTweets.publishDate, until),
      ),
    )
    .orderBy(desc(kolTweets.publishDate));

  if (!tweets.length) {
    return NextResponse.json({
      ok: true,
      handle,
      days,
      scannedTweets: 0,
      mentionsDetected: 0,
      inserted: 0,
      updated: 0,
    });
  }

  // When missingOnly=true, skip tweets that already have ANY mentions
  let candidates = tweets;
  if (missingOnly) {
    const existing = await db
      .select({ tweetId: tweetTokenMentions.tweetId })
      .from(tweetTokenMentions)
      .where(inArray(tweetTokenMentions.tweetId, tweets.map((t) => t.tweetId)));
    const has = new Set(existing.map((e) => e.tweetId));
    candidates = tweets.filter((t) => !has.has(t.tweetId));
  }

  // Extract mentions; note if any Solana CA exists (to force solana for tickers)
  const all: {
    tweetId: string;
    m: Mention;
    triggerKey: string;
    triggerText: string;
  }[] = [];
  const uniqueTickers = new Set<string>(); // "$TICKER"
  let seenSolanaCA = false;

  for (const t of candidates) {
    const ext = extractMentions(t.textContent ?? "");
    for (const m of ext) {
      const input = triggerInputFor(m);
      const { key, text } = buildTriggerKeyWithText({
        source: m.source as any,
        value: input,
      });

      all.push({
        tweetId: t.tweetId,
        m,
        triggerKey: key,
        triggerText: text,
      });

      if (m.source === "ca" && isSolAddr(m.tokenKey)) seenSolanaCA = true;

      if (m.source !== "ca") {
        const tk = m.tokenDisplay?.startsWith("$")
          ? m.tokenDisplay
          : `$${String(m.tokenKey || "").toUpperCase()}`;
        uniqueTickers.add(tk);
      }
    }
  }

  // Resolve tickers → tokenKey using GT
  const resolved = await resolveTickersToContracts(
    [...uniqueTickers],
    seenSolanaCA ? { forceNetwork: "solana" } : { preferSolana: true },
  );

  // Build DB rows; de-duplicate by (tweetId, triggerKey)
  type Row = {
    tweetId: string;
    tokenKey: string;
    tokenDisplay: string | null;
    confidence: number;
    source: (typeof mentionSource.enumValues)[number];
    triggerKey: string;
    triggerText: string | null;
  };
  const rows: Row[] = [];
  const seenPair = new Set<string>();

  for (const { tweetId, m, triggerKey, triggerText } of all) {
    let tokenKey = m.tokenKey;
    let tokenDisplay = m.tokenDisplay;
    let confidence = m.confidence;

    if (m.source === "ca") {
      // For CA: trust address form, no GT lookup
      tokenKey = canonAddr(String(m.tokenKey || ""));
      tokenDisplay = tokenDisplay ?? m.tokenKey;
    } else {
      // For ticker/phrase: prefer Solana + PumpSwap-first ranking
      const disp = m.tokenDisplay?.startsWith("$")
        ? m.tokenDisplay
        : `$${String(m.tokenKey || "").toUpperCase()}`;
      const r = resolved.get(disp.replace(/^\$+/, "").toLowerCase());
      if (r) {
        tokenKey = r.tokenKey;
        tokenDisplay = r.tokenDisplay;
        confidence = Math.max(confidence, r.boostedConf);
      }
    }

    const pair = `${tweetId}___${triggerKey}`;
    if (seenPair.has(pair)) continue;
    seenPair.add(pair);

    rows.push({
      tweetId,
      tokenKey: canonAddr(String(tokenKey || "")), // EVM lowercased; Solana preserved
      tokenDisplay: tokenDisplay ?? (m.tokenDisplay || m.tokenKey),
      confidence: Math.min(100, Math.max(0, Math.round(confidence))),
      source: (m.source as any) as Row["source"],
      triggerKey,
      triggerText,
    });
  }

  if (!rows.length) {
    return NextResponse.json({
      ok: true,
      handle,
      days,
      scannedTweets: candidates.length,
      mentionsDetected: 0,
      inserted: 0,
      updated: 0,
    });
  }

  // Accurate counts via pre-check (existing pairs)
  const tweetIds = Array.from(new Set(rows.map((r) => r.tweetId)));
  const triggers = Array.from(new Set(rows.map((r) => r.triggerKey)));
  const existingPairs = await db
    .select({
      tweetId: tweetTokenMentions.tweetId,
      triggerKey: tweetTokenMentions.triggerKey,
      tokenKey: tweetTokenMentions.tokenKey,
    })
    .from(tweetTokenMentions)
    .where(
      and(
        inArray(tweetTokenMentions.tweetId, tweetIds),
        inArray(tweetTokenMentions.triggerKey, triggers),
      ),
    );

  const existsMap = new Map(
    existingPairs.map((e) => [`${e.tweetId}___${e.triggerKey}`, e.tokenKey]),
  );
  const willInsert = rows.filter(
    (r) => !existsMap.has(`${r.tweetId}___${r.triggerKey}`),
  ).length;
  const willUpdate = rows.filter((r) => {
    const prev = existsMap.get(`${r.tweetId}___${r.triggerKey}`);
    return prev && prev !== r.tokenKey;
  }).length;

  // Upsert by (tweet_id, trigger_key), chunked
  const CHUNK = 200;
  for (let i = 0; i < rows.length; i += CHUNK) {
    const chunk = rows.slice(i, i + CHUNK);
    await db
      .insert(tweetTokenMentions)
      .values(chunk)
      .onConflictDoUpdate({
        target: [tweetTokenMentions.tweetId, tweetTokenMentions.triggerKey],
        set: {
          tokenKey: sql`excluded.token_key`,
          tokenDisplay: sql`excluded.token_display`,
          confidence: sql`excluded.confidence`,
          source: sql`excluded.source`,
          triggerText: sql`excluded.trigger_text`,
          updatedAt: sql`now()`,
        },
      });
  }

  return NextResponse.json({
    ok: true,
    handle,
    days,
    scannedTweets: candidates.length,
    mentionsDetected: rows.length,
    inserted: willInsert,
    updated: willUpdate,
  });
}

