// scripts/scout-ticker.ts
/* eslint-disable no-console */
/**
 * Ticker scouting CLI for Solana (GeckoTerminal-backed)
 *
 * Shows:
 *  - Full candidate list per ticker (ranked): DEX, quote, 24h vol, liquidity(reserve), mcap, trend, score, freq
 *  - The CA that current resolution logic would PICK (resolveTickersToContracts) marked with "*"
 *  - Aggregated-by-address view (addr frequency, total vol, total reserve, best DEX/quote)
 *
 * Flags:
 *  --mode=both|cands|resolve   (default: both)
 *  --top=N                     (default: 20)
 *  --out=DIR                   (default: ./.tmp ; saves JSON bundle)
 *  --csv=PATH                  (optional; dump aggregated rows for all tickers)
 *  --raw                       (print raw JSON objects instead of tables)
 *
 * Examples:
 *  npx ts-node -P tsconfig.scripts.json -r tsconfig-paths/register scripts/scout-ticker.ts "BONK WIF SAMO"
 *  npx ts-node -P tsconfig.scripts.json -r tsconfig-paths/register scripts/scout-ticker.ts "WIF" --mode=both --top=30 --csv=.tmp/wif.csv
 */

import fs from "fs";
import path from "path";
import {
  getTickerCandidatesVerbose,
  resolveTickersToContracts,
} from "@/lib/markets/geckoterminal";
import { TICKER_ALIASES } from "@/lib/markets/gt.util";

// Keep it flexible to avoid tight coupling with library types
type VerboseCand = {
  addr: string;
  symbol?: string;
  dexName?: string;
  quoteSymbol?: string;
  volume24h?: number;
  reserveUsd?: number;
  marketCap?: number;
  dexScore?: number;
  trendingBoost?: number;
  score?: number;
  addrFreq?: number;
};

type Mode = "both" | "cands" | "resolve";

type Args = {
  tickers: string[];
  topN: number;
  outDir: string | null;
  raw: boolean;
  mode: Mode;
  csvPath: string | null;
  debug: boolean;
  showVariants: boolean;
};

function parseArgs(): Args {
  const [, , ...rest] = process.argv;
  const joined = rest.join(" ");

  const mode = (joined.match(/--mode[=\s]+(both|cands|resolve)/i)?.[1] ||
    "both") as Mode;
  const topN = Math.max(
    1,
    Number(joined.match(/--top[=\s]+(\d+)/i)?.[1] || 20),
  );
  const outDir = (joined.match(/--out[=\s]+(\S+)/i)?.[1] || ".tmp") as string;
  const csvPath = (joined.match(/--csv[=\s]+(\S+)/i)?.[1] || null) as
    | string
    | null;
  const raw = /--raw\b/i.test(joined);
  const debug = /--debug\b/i.test(joined);
  const showVariants = /--variants\b/i.test(joined);

  // everything before the first flag is treated as tickers
  const firstFlagIdx = (() => {
    const keys = ["--mode", "--top", "--out", "--csv", "--raw"];
    const idxs = keys.map((k) => {
      const i = joined.indexOf(k);
      return i < 0 ? Infinity : i;
    });
    const min = Math.min(...idxs);
    return Number.isFinite(min) ? min : Infinity;
  })();

  const tickerStr =
    firstFlagIdx === Infinity ? joined : joined.slice(0, firstFlagIdx);
  const tickers = tickerStr
    .split(/[\s,]+/)
    .map((s) => s.replace(/^\$+/, "").trim().toUpperCase())
    .filter(Boolean);

  return { tickers, topN, outDir, raw, mode, csvPath, debug, showVariants };
}

function pad(s: string | number, w: number) {
  const str = String(s ?? "");
  if (str.length >= w) return str.slice(0, w);
  return str + " ".repeat(w - str.length);
}

function fmtNum(n: number | undefined | null) {
  const v = typeof n === "number" ? n : 0;
  if (v >= 1_000_000_000) return (v / 1_000_000_000).toFixed(2) + "B";
  if (v >= 1_000_000) return (v / 1_000_000).toFixed(2) + "M";
  if (v >= 1_000) return (v / 1_000).toFixed(2) + "K";
  return v.toFixed(0);
}

/**
 * Aggregate candidate rows by contract address.
 * Validates the heuristic: "the most repeated address across pools/DEXes is likely correct".
 */
function aggregateByAddr(rows: VerboseCand[]) {
  type Agg = {
    addr: string;
    symbol: string;
    freq: number;
    totalVol24h: number;
    totalReserve: number;
    bestDexScore: number;
    bestQuotePref: number; // 2: SOL/WSOL, 1: USDC, 0: others
  };
  const qp = (s?: string) =>
    s?.toUpperCase() === "SOL" || s?.toUpperCase() === "WSOL"
      ? 2
      : s?.toUpperCase() === "USDC"
        ? 1
        : 0;

  const agg = new Map<string, Agg>();
  for (const r of rows) {
    const a = r.addr;
    if (!a) continue;
    const prev = agg.get(a) || {
      addr: a,
      symbol: r.symbol || "",
      freq: 0,
      totalVol24h: 0,
      totalReserve: 0,
      bestDexScore: 0,
      bestQuotePref: 0,
    };
    prev.freq += 1;
    prev.totalVol24h += Number(r.volume24h || 0);
    prev.totalReserve += Number(r.reserveUsd || 0);
    prev.bestDexScore = Math.max(prev.bestDexScore, Number(r.dexScore || 0));
    prev.bestQuotePref = Math.max(prev.bestQuotePref, qp(r.quoteSymbol));
    if (!prev.symbol && r.symbol) prev.symbol = r.symbol; // keep a non-empty symbol
    agg.set(a, prev);
  }
  return Array.from(agg.values()).sort(
    (A, B) =>
      B.freq - A.freq ||
      B.totalVol24h - A.totalVol24h ||
      B.totalReserve - A.totalReserve ||
      B.bestDexScore - A.bestDexScore ||
      B.bestQuotePref - A.bestQuotePref,
  );
}

/** CSV dump helper (typed to avoid TS inference issues) */
function dumpCSV(pathname: string, rows: Array<Record<string, any>>) {
  // Build the column set explicitly through a typed reduce
  const colsSet: Set<string> = rows.reduce(
    (set: Set<string>, r: Record<string, any>) => {
      Object.keys(r).forEach((k) => set.add(k));
      return set;
    },
    new Set<string>(),
  );
  const cols = Array.from(colsSet);

  const esc = (v: any) => {
    const s = String(v ?? "");
    return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
  };
  const lines = [
    cols.join(","),
    ...rows.map((r) => cols.map((c) => esc(r[c])).join(",")),
  ];
  fs.writeFileSync(pathname, lines.join("\n"), "utf8");
}

async function main() {
  const { tickers, topN, outDir, raw, mode, csvPath } = parseArgs();
  if (!tickers.length) {
    console.error(
      'Usage: ts-node -P tsconfig.scripts.json -r tsconfig-paths/register scripts/scout-ticker.ts "BONK WIF ..." [--mode both|cands|resolve] [--top 20] [--out .tmp] [--csv ./file.csv] [--raw]',
    );
    process.exit(1);
  }

  // Enable low-level GT debug logging if requested
  if (debug) process.env.DEBUG_GT = "1";

  console.log(`🔎 Mode: ${mode} · Tickers: ${tickers.join(", ")}`);

  // 1) Full candidates (verbose)
  const verboseMap =
    mode === "resolve"
      ? new Map<string, VerboseCand[]>()
      : await getTickerCandidatesVerbose(tickers, topN);

  // 2) Resolution picks (what your current resolver will choose)
  const picksMap =
    mode === "cands"
      ? new Map<
          string,
          { tokenKey: string; tokenDisplay: string; boostedConf: number }
        >()
      : await resolveTickersToContracts(tickers);

  // Persist as a bundle for offline analysis
  const bundle: Record<string, any> = {};
  const csvAggRows: Array<Record<string, any>> = [];

  for (const t of tickers) {
    const key = t.toLowerCase();
    const rows: VerboseCand[] = verboseMap.get(key) || [];
    const pick = picksMap.get(key);

    if (raw) {
      console.log(`\n=== $${t} (raw) ===`);
      console.dir({ pick, rows }, { depth: null });
    } else {
      console.log(`\n=== $${t} ===`);
      if (showVariants) {
        const t0 = t.toLowerCase().replace(/^\$+/, "");
        const variants = new Set<string>([t0, `$${t0}`]);
        for (const alias of TICKER_ALIASES[t0] || []) {
          variants.add(alias.toLowerCase());
          variants.add(`$${alias.toLowerCase()}`);
        }
        console.log(`Queries: ${Array.from(variants).join(", ")}`);
      }
      if (pick) {
        console.log(
          `Pick: ${pick.tokenKey}  (${pick.tokenDisplay}, conf=${pick.boostedConf})`,
        );
      } else {
        console.log("Pick: (unresolved)");
      }

      if (mode !== "resolve") {
        // Candidate table (mark the picked row with '*')
        const header =
          pad("rank", 5) +
          pad("addr", 46) +
          pad("dex", 12) +
          pad("quote", 8) +
          pad("vol24h", 10) +
          pad("reserve", 10) +
          pad("mcap", 12) +
          pad("dexSc", 6) +
          pad("trend", 7) +
          pad("score", 10) +
          pad("freq", 6) +
          "  " +
          "symbol";
        console.log(header);
        console.log("-".repeat(header.length));

        const addrFreq = rows.reduce(
          (m, r) => m.set(r.addr, (m.get(r.addr) || 0) + 1),
          new Map<string, number>(),
        );

        rows.forEach((r, i) => {
          const isPick = pick?.tokenKey && r.addr === pick.tokenKey;
          const line =
            pad((isPick ? "*" : "") + String(i + 1), 5) +
            pad(r.addr, 46) +
            pad(r.dexName || "-", 12) +
            pad((r.quoteSymbol || "-").toUpperCase(), 8) +
            pad(fmtNum(r.volume24h), 10) +
            pad(fmtNum(r.reserveUsd), 10) +
            pad(fmtNum(r.marketCap), 12) +
            pad(r.dexScore ?? 0, 6) +
            pad((r.trendingBoost ?? 0).toFixed(1), 7) +
            pad((r.score ?? 0).toFixed(0), 10) +
            pad(r.addrFreq ?? addrFreq.get(r.addr) ?? 1, 6) +
            "  " +
            (r.symbol ? `$${r.symbol.toUpperCase()}` : "-");
          console.log(line);
        });

        if (!rows.length) {
          console.log("(no candidates after DEX/quote filters)");
        }

        // Aggregated-by-address view
        const agg = aggregateByAddr(rows);
        if (agg.length) {
          console.log("\n-- Aggregated by address --");
          const h2 =
            pad("addr", 46) +
            pad("freq", 6) +
            pad("vol24h(sum)", 14) +
            pad("reserve(sum)", 14) +
            pad("bestDEX", 7) +
            pad("bestQuote", 10) +
            "symbol";
          console.log(h2);
          console.log("-".repeat(h2.length));
          agg.forEach((a) => {
            const isPick = pick?.tokenKey && a.addr === pick.tokenKey;
            const line =
              pad((isPick ? "*" : "") + a.addr, 46) +
              pad(a.freq, 6) +
              pad(fmtNum(a.totalVol24h), 14) +
              pad(fmtNum(a.totalReserve), 14) +
              pad(a.bestDexScore, 7) +
              pad(a.bestQuotePref, 10) +
              (a.symbol ? `$${a.symbol.toUpperCase()}` : "-");
            console.log(line);
          });

          // collect CSV rows
          for (const a of agg) {
            csvAggRows.push({
              ticker: t.toUpperCase(),
              picked: pick?.tokenKey === a.addr ? "1" : "0",
              addr: a.addr,
              freq: a.freq,
              vol24h_sum: a.totalVol24h.toFixed(0),
              reserve_sum: a.totalReserve.toFixed(0),
              best_dex_score: a.bestDexScore,
              best_quote_pref: a.bestQuotePref,
              symbol: a.symbol || "",
              pick_tokenKey: pick?.tokenKey || "",
              pick_display: pick?.tokenDisplay || "",
              pick_conf: pick?.boostedConf ?? "",
            });
          }
        }
      }
    }

    // Bundle for JSON
    bundle[key] = { pick, candidates: rows };
  }

  // Save JSON
  if (outDir) {
    try {
      fs.mkdirSync(outDir, { recursive: true });
      const ts = new Date();
      const fpath = path.join(
        outDir,
        `scout-ticker-${ts.toISOString().replace(/[:.]/g, "-")}.json`,
      );
      fs.writeFileSync(fpath, JSON.stringify(bundle, null, 2), "utf8");
      console.log(`\n📝 Saved JSON to ${fpath}`);
    } catch {
      // ignore
    }
  }

  // Optional CSV export
  if (csvPath && csvAggRows.length) {
    dumpCSV(csvPath, csvAggRows);
    console.log(`📄 Saved CSV to ${csvPath}`);
  }
}

main().catch((e) => {
  console.error("❌ Scout failed:", e?.message || e);
  process.exit(1);
});
