// app/api/kols/maxroi/refresh/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { sql, inArray } from "drizzle-orm";
import { db } from "@/lib/db/client";
import {
  computeMaxPairsForCA,
  type MentionRow,
} from "@/lib/pricing/mentionMax";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

const Item = z.object({
  mentionId: z.string().min(1),
  ca: z.string().min(1),
  network: z.string().optional(),
  poolMode: z.enum(["primary", "top3"]).optional(),
  minVolume: z.coerce.number().nonnegative().optional(),
  minutePatch: z.coerce.boolean().optional(),
  minuteAgg: z.coerce.number().int().positive().optional(),
});
const Body = z.object({
  items: z.array(Item).min(1),
});

function toIsoOrNull(v: string | Date | null | undefined): string | null {
  if (!v) return null;
  if (v instanceof Date) return v.toISOString();
  const s = String(v).trim();
  if (!s) return null;
  if (/^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}(:\d{2}(\.\d{1,3})?)?$/.test(s)) {
    return new Date(s.replace(" ", "T") + "Z").toISOString();
  }
  const t = Date.parse(s);
  return Number.isFinite(t) ? new Date(t).toISOString() : null;
}

type DbRow = {
  id: string;
  publish_date: string | Date;
  token_key: string | null;
};

export async function POST(req: Request) {
  const url = new URL(req.url);
  const wantDebug = url.searchParams.get("debug") === "1";

  try {
    const parsed = Body.parse(await req.json());
    const nowIso = new Date().toISOString();

    const ids = parsed.items.map((x) => x.mentionId);
    const rows = await db.execute<DbRow>(sql`
      SELECT m.id, t.publish_date, m.token_key
      FROM tweet_token_mentions m
      JOIN kol_tweets t ON t.tweet_id = m.tweet_id
      WHERE ${inArray(sql.raw("m.id"), ids)}
    `);

    const byId = new Map<string, DbRow>();
    for (const r of rows.rows ?? []) byId.set(r.id, r);

    const groups = new Map<
      string,
      { ca: string; network: string; mentions: MentionRow[]; opts: any }
    >();

    for (const x of parsed.items) {
      const row = byId.get(x.mentionId);
      if (!row) continue;

      const network = (x.network || "solana").toLowerCase();
      // Prefer DB-resolved token_key; fallback to request CA.
      const ca = String(row.token_key || x.ca || "").trim();
      if (!ca) continue; // no CA, skip

      const key = `${network}::${ca}`;
      if (!groups.has(key)) {
        groups.set(key, {
          ca,
          network,
          mentions: [],
          opts: {
            network,
            poolMode: x.poolMode || "primary",
            minVolume: typeof x.minVolume === "number" ? x.minVolume : 0,
            minutePatch: x.minutePatch ?? true,
            minuteAgg: x.minuteAgg ?? 15,
            signal: undefined as AbortSignal | undefined,
          },
        });
      }

      groups.get(key)!.mentions.push({
        id: x.mentionId,
        publishDate: toIsoOrNull(row.publish_date)!,
      });
    }

    const updated: Array<{
      id: string;
      maxPrice: number | null;
      maxAt: string | null;
    }> = [];
    const skipped: Array<{ id: string; reason: string }> = [];
    const debug: any[] = [];

    for (const { ca, network, mentions, opts } of groups.values()) {
      if (!mentions.length) continue;

      try {
        const map = await computeMaxPairsForCA(ca, mentions, opts);

        for (const m of mentions) {
          const pair = map.get(m.id) || { maxPrice: null, maxAt: null };

          await db.execute(sql`
            UPDATE tweet_token_mentions
            SET
              max_price_since_mention     = ${pair.maxPrice},
              max_price_at_since_mention  = ${pair.maxAt},
              updated_at                  = now()
            WHERE id = ${m.id}
          `);

          updated.push({
            id: m.id,
            maxPrice: pair.maxPrice,
            maxAt: pair.maxAt,
          });
          if (wantDebug) debug.push({ ca, network, id: m.id, opts, pair });
        }
      } catch (e: any) {
        const reason = e?.message || "computeMaxPairsForCA failed";
        for (const m of mentions) {
          skipped.push({ id: m.id, reason });
        }
        if (wantDebug) debug.push({ ca, network, error: reason });
      }
    }

    return NextResponse.json(
      wantDebug ? { updated, skipped, debug } : { updated, skipped },
    );
  } catch (e: any) {
    return NextResponse.json(
      { error: e?.message || "Bad Request" },
      { status: 400 },
    );
  }
}

export async function GET() {
  return NextResponse.json({
    ok: true,
    usage:
      'POST /api/kols/maxroi/refresh {"items":[{"mentionId":"...", "ca":"<solana mint>", "network":"solana", "poolMode":"primary", "minVolume":1000, "minutePatch":true, "minuteAgg":15}]}',
  });
}
