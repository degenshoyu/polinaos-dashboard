// app/api/kols/coins/update-ca/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { db } from "@/lib/db/client";
import { coinCaTicker, tweetTokenMentions } from "@/lib/db/schema";
import { and, sql } from "drizzle-orm";

// Enrichment helpers
import { resolveCAtoMeta } from "@/lib/tokens/resolve";
import { fetchMintMeta } from "@/lib/mintmeta/fetch";
import { canonAddr } from "@/lib/chains/address";
// ⬇️ 新增：直接用 GT 的地址解析（支持 EVM）
import { resolveContractsToMeta } from "@/lib/markets/geckoterminal";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

/**
 * Body:
 *  - fromCa: old contract address (required)
 *  - toCa:   new contract address (required)
 *  - scopeTicker: optional; if provided, only move that ticker's mapping
 *                 examples: "DOGE" or "$DOGE" (we normalize by stripping '$' + UPPER)
 */
const Body = z.object({
  fromCa: z.string().trim().min(1),
  toCa: z.string().trim().min(1),
  scopeTicker: z.string().trim().optional(),
});

/** Derive absolute origin for server-side routes. */
function getOrigin(req: Request): string {
  const h = req.headers;
  const xfProto = h.get("x-forwarded-proto");
  const xfHost = h.get("x-forwarded-host");
  const host = xfHost || h.get("host") || process.env.VERCEL_URL || "";
  const proto = xfProto || (process.env.VERCEL ? "https" : "http");
  const envOrigin =
    process.env.NEXT_PUBLIC_APP_URL ||
    process.env.APP_URL ||
    process.env.SITE_URL ||
    "";
  if (host) return `${proto}://${host}`;
  if (envOrigin) return envOrigin.replace(/\/$/, "");
  return "http://localhost:3000";
}

/** Safe number→Date (supports epoch seconds or ms). */
function numToDate(n?: number | null): Date | null {
  if (n == null) return null;
  const ms = n > 1e12 ? n : n * 1000;
  const d = new Date(ms);
  return isNaN(d.getTime()) ? null : d;
}

/**
 * Try to get {symbol, tokenName, primaryPoolAddress} by address.
 * Order:
 *  1) resolveCAtoMeta (Solana-only)
 *  2) resolveContractsToMeta([addr]) from geckoterminal (works for EVM too)
 */
async function getNameMetaByAddress(addr: string) {
  // 1) Solana fast-path
  const sol = await resolveCAtoMeta(addr).catch(() => null);
  if (sol?.symbol && sol?.tokenName) {
    return {
      symbol: sol.symbol,
      tokenName: sol.tokenName,
      primaryPoolAddress: sol.primaryPoolAddress ?? null,
      source: "resolveCAtoMeta",
      snapshot: sol,
    };
  }

  // 2) Generic GT fallback (supports EVM)
  const map = await resolveContractsToMeta([addr]).catch(() => null);
  const m =
    map?.get(addr) ||
    map?.get(addr.toLowerCase()) ||
    map?.get(addr.toUpperCase());
  if (m && (m.symbol || m.tokenName)) {
    return {
      symbol: m.symbol ?? null,
      tokenName: m.tokenName ?? null,
      primaryPoolAddress: (m as any).primaryPoolAddress ?? null,
      source: "geckoterminal:addr",
      snapshot: m,
    };
  }

  return null;
}

/** Enrich one (ticker, toCa) row in coin_ca_ticker (outside txn). */
async function enrichOne(req: Request, tickerUpper: string, toCaRaw: string) {
  const toCaCanon = canonAddr(toCaRaw);
  const now = new Date();

  // Ensure the row exists so UPDATE will match
  await db.execute(sql`
    INSERT INTO coin_ca_ticker (token_ticker, contract_address, updated_at)
    VALUES (${tickerUpper}, ${toCaCanon}, ${now})
    ON CONFLICT (token_ticker, contract_address) DO UPDATE
      SET updated_at = EXCLUDED.updated_at
  `);

  // ----- Display/name meta -----
  const nameMeta = await getNameMetaByAddress(toCaCanon);

  // ----- On-chain provenance -----
  const origin = getOrigin(req);
  const mintmeta = await fetchMintMeta(origin, toCaCanon, {
    tz: "UTC",
    strategy: "cheap",
    max: 2000,
  }).catch(() => null);

  // Map to DB columns
  const setData: Record<string, any> = { updatedAt: now };

  // token_name / primary_pool_address / token_metadata
  if (nameMeta) {
    const tokenName = nameMeta.tokenName || nameMeta.symbol || tickerUpper; // always give a non-empty fallback
    setData.tokenName = tokenName;
    if (Object.prototype.hasOwnProperty.call(nameMeta, "primaryPoolAddress")) {
      setData.primaryPoolAddress = nameMeta.primaryPoolAddress ?? null;
    }
    // keep both snapshots for auditing
    setData.tokenMetadata = {
      source: nameMeta.source,
      resolve: nameMeta.snapshot ?? null,
      mintmeta,
    };
  } else {
    // no meta found — at least persist mintmeta snapshot if available
    if (mintmeta) {
      setData.tokenMetadata = { source: "mintmeta-only", mintmeta };
    }
  }

  if (mintmeta) {
    const creators = Array.isArray(mintmeta.creators) ? mintmeta.creators : [];
    const verified = creators.find((c: any) => c?.verified);
    const first = creators[0];

    setData.creatorAddress = verified?.address || first?.address || null;

    if ("mintAuthority" in mintmeta) {
      setData.mintAuthority = mintmeta.mintAuthority || null;
      setData.hasMintAuth =
        typeof mintmeta.hasMintAuthority === "boolean"
          ? mintmeta.hasMintAuthority
          : Boolean(mintmeta.mintAuthority);
    }
    if ("freezeAuthority" in mintmeta) {
      setData.hasFreezeAuth =
        typeof mintmeta.hasFreezeAuthority === "boolean"
          ? mintmeta.hasFreezeAuthority
          : Boolean(mintmeta.freezeAuthority);
    }
    if ("updateAuthority" in mintmeta) {
      setData.updateAuthority = mintmeta.updateAuthority || null;
    }

    const dIso =
      typeof mintmeta.mintedAtISO === "string"
        ? new Date(mintmeta.mintedAtISO)
        : null;
    const dNum = numToDate(
      typeof mintmeta.mintedAt === "number" ? mintmeta.mintedAt : null,
    );
    setData.mintAt = dIso && !isNaN(dIso.getTime()) ? dIso : dNum;
  }

  // Apply update only if we have fields to set
  if (Object.keys(setData).length > 0) {
    await db
      .update(coinCaTicker)
      .set(setData)
      .where(
        and(
          sql`upper(${coinCaTicker.tokenTicker}) = ${tickerUpper}`,
          sql`lower(${coinCaTicker.contractAddress}) = lower(${toCaCanon})`,
        ),
      );
  }
}

export async function POST(req: Request) {
  try {
    const { fromCa, toCa, scopeTicker } = Body.parse(await req.json());
    if (fromCa === toCa) {
      return NextResponse.json({
        ok: true,
        mode: "noop",
        movedTickers: 0,
        changedCa: 0,
        clearedPrice: 0,
        enriched: 0,
      });
    }

    const normTicker = scopeTicker
      ? scopeTicker.replace(/^\$/, "").trim().toUpperCase()
      : null;

    // Mentions scope (case-insensitive by CA, optional ticker via token_display)
    const whereFromCa = and(
      sql`lower(${tweetTokenMentions.tokenKey}) = lower(${fromCa})`,
      normTicker
        ? sql`upper(trim(both ' $' from ${tweetTokenMentions.tokenDisplay})) = ${normTicker}`
        : sql`true`,
    );
    const whereToCa = and(
      sql`lower(${tweetTokenMentions.tokenKey}) = lower(${toCa})`,
      normTicker
        ? sql`upper(trim(both ' $' from ${tweetTokenMentions.tokenDisplay})) = ${normTicker}`
        : sql`true`,
    );

    const now = new Date();

    // A+B atomic: migrate coin_ca_ticker and rewrite mentions
    const { tickersMoved, changedCa, clearedPrice } = await db.transaction(
      async (tx) => {
        const moved = normTicker
          ? await tx.execute(sql`
              WITH moved AS (
                DELETE FROM coin_ca_ticker
                WHERE UPPER(token_ticker) = ${normTicker}
                  AND lower(contract_address) = lower(${fromCa})
                RETURNING token_ticker
              )
              INSERT INTO coin_ca_ticker (token_ticker, contract_address, updated_at)
              SELECT COALESCE((SELECT token_ticker FROM moved LIMIT 1), ${normTicker}), ${toCa}, ${now}
              ON CONFLICT (token_ticker, contract_address) DO UPDATE
                SET updated_at = EXCLUDED.updated_at
              RETURNING token_ticker;
            `)
          : await tx.execute(sql`
              WITH moved AS (
                DELETE FROM coin_ca_ticker
                WHERE lower(contract_address) = lower(${fromCa})
                RETURNING token_ticker
              )
              INSERT INTO coin_ca_ticker (token_ticker, contract_address, updated_at)
              SELECT token_ticker, ${toCa}, ${now} FROM moved
              ON CONFLICT (token_ticker, contract_address) DO UPDATE
                SET updated_at = EXCLUDED.updated_at
              RETURNING token_ticker;
            `);

        const tickersMoved = Array.isArray(moved?.rows)
          ? Array.from(
              new Set(
                moved.rows
                  .map((r: any) => String(r.token_ticker || "").toUpperCase())
                  .filter(Boolean),
              ),
            )
          : [];

        if (normTicker && tickersMoved.length === 0) {
          // Even if no source row, we still want to upsert/enrich target mapping
          tickersMoved.push(normTicker);
        }

        const r1 = await tx
          .update(tweetTokenMentions)
          .set({ tokenKey: toCa, priceUsdAt: null })
          .where(whereFromCa);
        const r2 = await tx
          .update(tweetTokenMentions)
          .set({ priceUsdAt: null })
          .where(whereToCa);

        return {
          tickersMoved,
          changedCa: Number((r1 as any)?.rowCount ?? 0),
          clearedPrice: Number((r2 as any)?.rowCount ?? 0),
        };
      },
    );

    // C) Enrich all affected tickers (best-effort, outside the transaction)
    let enrichedCount = 0;
    for (const t of tickersMoved) {
      try {
        await enrichOne(req, t, toCa);
        enrichedCount += 1;
      } catch {
        // swallow enrichment errors; migration already succeeded
      }
    }

    return NextResponse.json({
      ok: true,
      mode: tickersMoved.length > 0 ? "migrated" : "upserted_or_noop",
      movedTickers: tickersMoved.length,
      changedCa,
      clearedPrice,
      enriched: enrichedCount,
      tickers: tickersMoved,
    });
  } catch (e: any) {
    return NextResponse.json(
      { ok: false, error: e?.message ?? "failed" },
      { status: 400 },
    );
  }
}
