// hooks/useGeckoSearch.ts
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";

/**
 * Minimal types from GeckoTerminal search/pools response
 */
type GTApiPool = {
  id: string; // e.g. "solana_22Wr..."
  type: "pool";
  attributes: {
    name: string; // "MOODENG / SOL"
    address: string;
    pool_created_at?: string;
    base_token_price_usd?: string | null;
    quote_token_price_usd?: string | null;
    base_token_price_quote_token?: string | null;

    price_change_percentage?: {
      m5?: string;
      m15?: string;
      m30?: string;
      h1?: string;
      h6?: string;
      h24?: string;
    };

    transactions?: any;

    volume_usd?: {
      m5?: string | null;
      m15?: string | null;
      m30?: string | null;
      h1?: string | null;
      h6?: string | null;
      h24?: string | null;
    };

    reserve_in_usd?: string | null; // liquidity
    market_cap_usd?: string | null;
    fdv_usd?: string | null;
  };
  relationships: {
    base_token?: { data?: { id: string; type: "token" } | null };
    quote_token?: { data?: { id: string; type: "token" } | null };
    dex?: { data?: { id: string; type: "dex" } | null };
  };
};

type GTApiToken = {
  id: string; // e.g. "solana_ED5n..."
  type: "token";
  attributes: {
    address: string;
    name: string;
    symbol: string; // ticker
    image_url?: string | null;
    decimals?: number;
    website_url?: string | null;
  };
};

type GTIncluded = (GTApiToken | { id: string; type: "dex"; attributes?: { name?: string } })[];

/** Unified option for our combobox */
export type TokenOption = {
  score: number;
  // ids
  poolId: string;
  baseTokenId: string;
  // visuals
  logo?: string | null;
  // labels
  symbol: string;
  name: string;
  chain: string; // derived from token id prefix, e.g. "solana", "ethereum"
  dex?: string | null;

  // numbers (already parsed to number)
  priceUsd?: number | null;
  vol24h?: number;
  liquidity?: number;
  marketCap?: number | null;
  fdv?: number | null;

  // misc
  pairName: string;
  poolAddress: string;
  tokenAddress: string;
  poolAge?: string | null; // humanized later if needed
};

export type UseGeckoSearchOptions = {
  /** debounce in ms for typing */
  debounceMs?: number;
  /** optional: boost certain chains */
  preferredChains?: Array<"solana" | "ethereum" | string>;
  /** minimum result count to return (after grouping) */
  limit?: number;
  /** GeckoTerminal API host (allow override/mocking) */
  apiBase?: string;
};

const DEFAULTS: Required<Pick<UseGeckoSearchOptions, "debounceMs" | "preferredChains" | "limit" | "apiBase">> = {
  debounceMs: 250,
  preferredChains: [],
  limit: 20,
  apiBase: "https://api.geckoterminal.com/api/v2",
};

function toNum(v?: string | null): number {
  if (!v) return 0;
  const n = Number(v);
  return isFinite(n) ? n : 0;
}

function chainFromId(id?: string): string {
  // e.g. "solana_ED5n..." -> "solana"
  if (!id) return "";
  const idx = id.indexOf("_");
  return idx > 0 ? id.slice(0, idx) : "";
}

function extractTicker(pairName: string, baseSym?: string): string {
  // Prefer base token symbol if provided
  if (baseSym && baseSym.trim()) return baseSym.trim().toUpperCase();
  // Otherwise try to split "MOODENG / SOL"
  const m = pairName?.split("/")[0]?.trim();
  return (m || "").toUpperCase();
}

function nameMatchBoost(query: string, symbol: string, name: string): number {
  const q = query.trim().toLowerCase();
  if (!q) return 0;
  const sym = symbol.toLowerCase();
  const nm = (name || "").toLowerCase();

  // strong boosts for exact match on symbol
  if (sym === q) return 3.0;
  if (sym.startsWith(q)) return 1.0;
  if (sym.includes(q)) return 0.5;

  // small boost if name matches
  if (nm === q) return 0.6;
  if (nm.startsWith(q)) return 0.3;
  if (nm.includes(q)) return 0.15;

  return 0;
}

function chainSmallBoost(chain: string, preferred: string[]): number {
  if (!preferred?.length) return 0;
  const i = preferred.findIndex((c) => c.toLowerCase() === chain.toLowerCase());
  if (i < 0) return 0;
  // first preference +0.3, second +0.2, others +0.1
  return Math.max(0.1, 0.3 - i * 0.1);
}

/**
 * Score pools with emphasis:
 *  - 24h volume (primary)
 *  - liquidity (secondary)
 *  - mcap/fdv (tertiary)
 *  - name/ticker exact-match boost
 *  - (optional) chain preference boost
 */
function scorePool(
  vol24h: number,
  liq: number,
  mcapOrFdv: number,
  nameBoost: number,
  chainBoost: number
): number {
  // log scale to tame huge numbers; +1 to avoid log(0)
  const sVol = Math.log10(1 + Math.max(0, vol24h));
  const sLiq = Math.log10(1 + Math.max(0, liq));
  const sCap = Math.log10(1 + Math.max(0, mcapOrFdv));
  return 3.0 * sVol + 1.6 * sLiq + 1.2 * sCap + nameBoost + chainBoost;
}

function uniqBy<T>(arr: T[], key: (t: T) => string): T[] {
  const m = new Map<string, T>();
  for (const it of arr) {
    const k = key(it);
    const prev = m.get(k);
    // keep the higher score if duplicated
    if (!prev) m.set(k, it);
    else {
      const a = (it as any).score ?? 0;
      const b = (prev as any).score ?? 0;
      if (a > b) m.set(k, it);
    }
  }
  return Array.from(m.values());
}

export function useGeckoSearch(opts?: UseGeckoSearchOptions) {
  const { debounceMs, preferredChains, limit, apiBase } = { ...DEFAULTS, ...(opts || {}) };

  const [query, setQuery] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [results, setResults] = useState<TokenOption[]>([]);

  const qRef = useRef(query);
  useEffect(() => {
    qRef.current = query;
  }, [query]);

  // debounced searching
  useEffect(() => {
    if (!query.trim()) {
      setResults([]);
      setError(null);
      return;
    }

    const t = setTimeout(async () => {
      setLoading(true);
      setError(null);

      try {
        const url = `${apiBase}/search/pools?query=${encodeURIComponent(
          query.trim()
        )}&include=base_token,quote_token`;
        const res = await fetch(url, {
          headers: { accept: "application/json" },
          cache: "no-store",
        });

        if (!res.ok) {
          throw new Error(`GeckoTerminal HTTP ${res.status}`);
        }

        const json = (await res.json()) as {
          data?: GTApiPool[];
          included?: GTIncluded;
        };

        const included = json?.included || [];
        const tokenMap = new Map<string, GTApiToken>();
        for (const inc of included) {
          if (inc.type === "token") tokenMap.set(inc.id, inc as GTApiToken);
        }

        const pools = (json?.data || []) as GTApiPool[];

        const mapped: TokenOption[] = pools.map((p) => {
          const baseId = p.relationships?.base_token?.data?.id || "";
          const quoteId = p.relationships?.quote_token?.data?.id || "";
          const dexId = p.relationships?.dex?.data?.id || null;

          const base = tokenMap.get(baseId || "");
          const quote = tokenMap.get(quoteId || "");

          const baseSym = base?.attributes?.symbol || "";
          const chain = chainFromId(base?.id || baseId);
          const ticker = extractTicker(p.attributes?.name, baseSym);

          const priceUsd = toNum(p.attributes.base_token_price_usd);
          const vol24h = toNum(p.attributes.volume_usd?.h24);
          const liquidity = toNum(p.attributes.reserve_in_usd);
          const mcap = toNum(p.attributes.market_cap_usd);
          const fdv = toNum(p.attributes.fdv_usd);
          const capOrFdv = mcap || fdv || 0;

          const nBoost = nameMatchBoost(qRef.current, ticker, base?.attributes?.name || "");
          const cBoost = chainSmallBoost(chain, preferredChains);

          const score = scorePool(vol24h, liquidity, capOrFdv, nBoost, cBoost);

          const opt: TokenOption = {
            score,
            poolId: p.id,
            baseTokenId: baseId,
            pairName: p.attributes.name,
            poolAddress: p.attributes.address,
            tokenAddress: base?.attributes?.address || "",

